{"id":"js/background/shaders/background.frag","dependencies":[{"name":"C:\\Users\\Johan\\Documents\\dev\\jfagerberg\\node_modules\\glsl-noise\\simplex\\3d.glsl","includedInParent":true,"mtime":1578678848465},{"name":"C:\\Users\\Johan\\Documents\\dev\\jfagerberg\\package.json","includedInParent":true,"mtime":1589893760361}],"generated":{"js":"module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\nuniform float u_time;\\nuniform vec2 u_resolution;\\nuniform vec2 u_mousepos;\\nuniform vec2 u_offset;\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvec3 c1 = vec3(30, 30, 35) / 255.0;\\nvec3 c2 = vec3(34, 34, 39) / 255.0;\\nvec3 c3 = vec3(36, 36, 42) / 255.0;\\nvec3 c4 = vec3(40, 40, 45) / 255.0;\\nvec3 c5 = vec3(43, 43, 48) / 255.0;\\nvoid main() {    \\n    vec2 normalized_pos = gl_FragCoord.xy / u_resolution;\\n    normalized_pos.x *= u_resolution.x / u_resolution.y; // remove stretching\\n    \\n    float time = u_time / 75000.0;\\n    vec2 offset = vec2(0, (u_offset.y - 0.5) * 3.0);\\n    offset.x *= u_resolution.x / u_resolution.y;\\n    normalized_pos *= 0.6; // make the blobs bigger\\n    offset *= -0.5;\\n    normalized_pos.x += u_offset.x * 0.2;\\n\\n    // TODO: replace with a single lookup texture so we don't compute noise 5 times\\n    float c5scale = 1.0 - step(0.6, snoise(vec3(normalized_pos + offset * 0.4, time)));\\n    float c4scale = 1.0 - step(0.2, snoise(vec3(normalized_pos + offset * 0.3, time))) - c5scale;\\n    float c3scale = 1.0 - step(-0.2, snoise(vec3(normalized_pos + offset * 0.2, time))) - c4scale - c5scale;\\n    float c2scale = 1.0 - step(-0.6, snoise(vec3(normalized_pos + offset * 0.1, time))) - c3scale - c4scale - c5scale;\\n    float c1scale = 1.0 - c2scale - c3scale - c4scale - c5scale;\\n    gl_FragColor = vec4(c1 * c1scale + c2 * c2scale + c3 * c3scale + c4 * c4scale + c5 * c5scale, 1.0);\\n    return;\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/background/shaders/background.frag","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/background/shaders/background.frag","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/background/shaders/background.frag","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/background/shaders/background.frag","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/background/shaders/background.frag","original":{"line":1,"column":15}},{"generated":{"line":1,"column":4414},"source":"js/background/shaders/background.frag","original":{"line":1,"column":0}}],"sources":{"js/background/shaders/background.frag":"module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\nuniform float u_time;\\nuniform vec2 u_resolution;\\nuniform vec2 u_mousepos;\\nuniform vec2 u_offset;\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvec3 c1 = vec3(30, 30, 35) / 255.0;\\nvec3 c2 = vec3(34, 34, 39) / 255.0;\\nvec3 c3 = vec3(36, 36, 42) / 255.0;\\nvec3 c4 = vec3(40, 40, 45) / 255.0;\\nvec3 c5 = vec3(43, 43, 48) / 255.0;\\nvoid main() {    \\n    vec2 normalized_pos = gl_FragCoord.xy / u_resolution;\\n    normalized_pos.x *= u_resolution.x / u_resolution.y; // remove stretching\\n    \\n    float time = u_time / 75000.0;\\n    vec2 offset = vec2(0, (u_offset.y - 0.5) * 3.0);\\n    offset.x *= u_resolution.x / u_resolution.y;\\n    normalized_pos *= 0.6; // make the blobs bigger\\n    offset *= -0.5;\\n    normalized_pos.x += u_offset.x * 0.2;\\n\\n    // TODO: replace with a single lookup texture so we don't compute noise 5 times\\n    float c5scale = 1.0 - step(0.6, snoise(vec3(normalized_pos + offset * 0.4, time)));\\n    float c4scale = 1.0 - step(0.2, snoise(vec3(normalized_pos + offset * 0.3, time))) - c5scale;\\n    float c3scale = 1.0 - step(-0.2, snoise(vec3(normalized_pos + offset * 0.2, time))) - c4scale - c5scale;\\n    float c2scale = 1.0 - step(-0.6, snoise(vec3(normalized_pos + offset * 0.1, time))) - c3scale - c4scale - c5scale;\\n    float c1scale = 1.0 - c2scale - c3scale - c4scale - c5scale;\\n    gl_FragColor = vec4(c1 * c1scale + c2 * c2scale + c3 * c3scale + c4 * c4scale + c5 * c5scale, 1.0);\\n    return;\\n}\";"},"lineCount":null}},"error":null,"hash":"652d6903cf586b2983fc0ec9a80cfadf","cacheData":{"env":{}}}